# 模块一（主控制脚本）——详细步骤与伪代码（按你的新约束）

> 目标：在 Jupyter Notebook 中，用 GEE + geemap 调用“能在 GEE 获取的数据”；CYGNSS 改为“本地读取”；自动判断哪些天有 CYGNSS 观测；在主程序中配置 EnKF 的初始化与 Q/R；内嵌一个合理的敏感性分析（LHS）。

---

## 步骤总览

1. **环境与依赖初始化**
   - `import` 必要库：`ee`, `geemap`, `geopandas`, `shapely`, `xarray`, `numpy`, `pandas`, `scipy.stats.qmc` 等。
   - 初始化 GEE：`ee.Initialize()`（你已授权）。
   - 设置全局随机种子/显示选项。

2. **读取 AOI（GeoJSON）**
   - 从用户提供的 GeoJSON 路径读取（`geopandas.read_file`）。
   - 若几何为多面/多部件，统一 dissolve 为一个单多边形。
   - 同时生成：
     - `aoi_polygon`（shapely，用于本地 CYGNSS 的点落区判定）
     - `aoi_ee_geom`（ee.Geometry，用于 GEE 数据过滤）

3. **设置时间范围与分辨率**
   - 用户输入开始/结束日期（UTC）。
   - 生成日序列 `pd.date_range(start, end, freq="D", tz="UTC")`。
   - 记录你的目标分辨率（3 km），作为后续栅格/聚合的参数（模块一仅记录）。

4. **GEE 数据集探测与可用性判断（“能拿就拿，不能拿你再下载”）**
   - 设定候选数据集 ID 列表（多版本/多来源）：
     - IMERG：`NASA/GPM_L3/IMERG_V07` 或 `V06`
     - ERA5-Land：`ECMWF/ERA5_LAND/HOURLY`（后续可推导 T 日均；PET 可延后或另算）
     - MODIS NDVI：`MODIS/061/MOD13Q1`（备选：`006/MOD13Q1`,`061/MYD13Q1`）
   - 函数 `gee_ic_available(ic_id) -> bool`：`ee.ImageCollection(ic_id).size().getInfo()` 成功即存在。
   - 函数 `gee_ic_has_data(ic_id, aoi, start, end) -> bool/int`：`filterDate + filterBounds + size()` 获取日期段与 AOI 的影像计数。
   - 根据可用性，记录 `available['imerg'] / ['era5_land'] / ['ndvi'] = { 'dataset_id': xxx, 'has_data': bool }`
   - 不进行大规模下载/聚合，只做“是否可用”的探测。**决定逻辑**：
     - 若可用且有数据：后续模块从 GEE 拉取、聚合。
     - 若不可用或无数据：主脚本记录 `requires_local_download = True`，提醒你线下下载（模块一仅记录）。

5. **本地 CYGNSS 数据读取与“每日有/无观测”判断**
   - 从你提供的本地 CYGNSS 文件列表/目录读取（建议 NetCDF/HDF5 -> `xarray.open_mfdataset`）。
   - 自动猜测经纬度与时间维变量名（多候选）。
   - 先做 AOI **外接矩形** 快速裁剪，再用 shapely `point.within(aoi_polygon)` 精筛。
   - 将反射点按 UTC 日期分组计数；设阈值 `min_hits_per_day`（如 `>= 10` 个点）定义“这天有有效观测”。
   - 输出 `cygnss_daily_coverage: pd.Series(bool)`，索引为日序列。

6. **构建“每日运行计划表”**
   - 初始化 DataFrame：列包含 `date`, `has_cygnss`, `gee_imerg_ok`, `gee_era5_ok`, `gee_ndvi_ok`, `ready_for_assim`。
   - 规则：`ready_for_assim = has_cygnss & (gee_imerg_ok or local_imerg) & (gee_era5_ok or local_era5) & (gee_ndvi_ok or local_ndvi)`
   - 将这个“计划表”CSV 输出，供后续模块使用。

7. **EnKF 滤波器参数在主程序中配置**
   - `state_init_mean = [SM0, VWC0]`
   - `state_init_cov = diag([σ_SM0^2, σ_VWC0^2])`
   - `Q = diag([σ_Q_SM^2, σ_Q_VWC^2])`
   - `R = diag([σ_R_refl^2])`
   - 观测模型参数：`inc_angle_deg`, `surf_rms_height_m`, `veg_b`
   - 这些作为字典 `enkf_config` 存档。

8. **敏感性分析（拉丁超立方 LHS）**
   - 给出参数范围（如 SM0∈[0.10,0.35], VWC0∈[0.5,3.0], σ_Q_SM∈[0.005,0.03], σ_R_refl∈[0.01,0.05], inc_angle∈[30°,55°], rms∈[0.005,0.03], veg_b∈[0.08,0.20]）。
   - 用 `scipy.stats.qmc.LatinHypercube(d=len_params)` 采样 N 组（如 N=50）。
   - 将采样映射到实际范围，生成参数组合表 `lhs_params_df`。
   - **此处仅生成配置，不真正跑同化**（模块一不调用昂贵计算），保存 CSV，供模块二批量读取执行。

9. **产物**
   - `availability_report.json / .csv`：记录 GEE 可用性、CYGNSS 覆盖、每日是否可同化。
   - `enkf_config.json`：当前默认滤波参数。
   - `lhs_params.csv`：敏感性分析的参数组合列表。

---

## 伪代码（Python风格）

```python
def main_module1(aoi_geojson_path, local_cygnss_paths, start_date, end_date):
    # 0. imports & init
    import ee, geemap, geopandas as gpd, pandas as pd, numpy as np
    from scipy.stats.qmc import LatinHypercube
    ee.Initialize()

    # 1. load AOI
    gdf = gpd.read_file(aoi_geojson_path)
    aoi_gdf = dissolve_to_single_polygon(gdf)
    aoi_polygon = shapely.geometry.shape(aoi_gdf.geometry.iloc[0])
    aoi_ee = geemap.geopandas_to_ee(aoi_gdf)

    # 2. build daily date index
    dates = pd.date_range(start_date, end_date, freq="D", tz="UTC")

    # 3. GEE dataset availability
    ds_candidates = {
      "imerg": ["NASA/GPM_L3/IMERG_V07", "NASA/GPM_L3/IMERG_V06"],
      "era5_land": ["ECMWF/ERA5_LAND/HOURLY"],
      "modis_ndvi": ["MODIS/061/MOD13Q1", "MODIS/006/MOD13Q1", "MODIS/061/MYD13Q1"]
    }
    availability = {}
    for key, ids in ds_candidates.items():
        availability[key] = choose_first_available_ic(ids, aoi_ee, start_date, end_date)

    # 4. local CYGNSS coverage by day
    cygnss_df = read_local_cygnss_to_df(local_cygnss_paths)         # columns: time, lat, lon, reflectivity, ...
    cygnss_df = spatial_filter_df_by_aoi(cygnss_df, aoi_polygon)     # filter points within AOI
    coverage_series = daily_coverage(cygnss_df, threshold=10)        # True/False per day

    # 5. build run-plan table
    plan = pd.DataFrame({"date": dates})
    plan["has_cygnss"] = plan["date"].map(lambda d: coverage_series.get(d.floor("D"), False))
    plan["gee_imerg_ok"] = availability["imerg"]["has_data"]
    plan["gee_era5_ok"] = availability["era5_land"]["has_data"]
    plan["gee_ndvi_ok"] = availability["modis_ndvi"]["has_data"]
    # allow local fallback flags (user to fill later)
    plan["local_imerg"] = False
    plan["local_era5"]  = False
    plan["local_ndvi"]  = False
    plan["ready_for_assim"] = plan["has_cygnss"] & (
        plan["gee_imerg_ok"] | plan["local_imerg"]
    ) & (
        plan["gee_era5_ok"]  | plan["local_era5"]
    ) & (
        plan["gee_ndvi_ok"]  | plan["local_ndvi"]
    )

    # 6. configure EnKF params in main
    enkf_config = {
      "state_init_mean": [0.25, 1.0],
      "state_init_std":  [0.02, 0.4],
      "Q_std":           [0.015, 0.15],
      "R_std":           [0.02],
      "obs_params": {
         "inc_angle_deg": 40.0,
         "surf_rms_height_m": 0.01,
         "veg_b": 0.12
      }
    }

    # 7. sensitivity analysis (LHS)
    param_ranges = {
      "SM0": (0.10, 0.35), "VWC0": (0.5, 3.0),
      "Q_SM": (0.005, 0.03), "Q_VWC": (0.05, 0.30),
      "R_refl": (0.01, 0.05),
      "inc_angle": (30.0, 55.0), "rms_h": (0.005, 0.03), "veg_b": (0.08, 0.20)
    }
    lhs_df = latin_hypercube_table(param_ranges, n_samples=50, seed=42)

    # 8. export artifacts
    save_json("availability_report.json", availability)
    plan.to_csv("daily_run_plan.csv", index=False)
    save_json("enkf_config.json", enkf_config)
    lhs_df.to_csv("lhs_params.csv", index=False)

    # 9. done - return structured objects
    return {
      "aoi_ee": aoi_ee, "aoi_polygon": aoi_polygon,
      "availability": availability,
      "daily_plan": plan,
      "enkf_config": enkf_config,
      "lhs_params": lhs_df
    }
